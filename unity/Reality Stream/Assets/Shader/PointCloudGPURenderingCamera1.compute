// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PointCloudCamera_1
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

// Input frames
Texture2D<float4> inColor;
Texture2D<float4> inDepthLower;
Texture2D<float4> inDepthUpper;

// Output frame
RWStructuredBuffer<float4> colorOut;
RWStructuredBuffer<float3> depthOut;

// RGB Camera info
int xColorOffset;
int yColorOffset;
float4 camInfoColor;
float4 camInfoDepth;

int colorImageWidth;
int colorImageHeight;

uint depthImageWidth;
uint depthImageHeight;

float4x4 cameraTransform;

[numthreads(32,32,1)]
void PointCloudCamera_1 (uint3 id : SV_DispatchThreadID)
{
    uint pixelID = (id.y * colorImageWidth + id.x);
    float depth = (float)(((inDepthLower[id.xy].g * 256.0) + (inDepthUpper[id.xy].g * 256.0 * 256.0)) * 0.001);
    // float depth = 0.4;
    if(depth > 0)
    {
        float z = depth ;
        float x = ((id.x - camInfoDepth[0]) * depth / camInfoDepth[2]);
        float y = ((id.y - camInfoDepth[1]) * depth / camInfoDepth[3]);

        int colColor = (int)((x / z * camInfoColor[2]) + camInfoColor[0]) + xColorOffset;
        int rowColor = (int)((y / z * camInfoColor[3]) + camInfoColor[1]) + yColorOffset;

        if(colColor >= 0 && colColor < colorImageWidth && rowColor >= 0 && rowColor < colorImageHeight)
        {
            colorOut[pixelID] = inColor[int2(colColor,rowColor)];
        } 

        float4x4 pointInCam = {1,0,0,x,0,1,0,y,0,0,1,z,1,1,1,1};
        float4x4 pointInWorld = mul(cameraTransform,pointInCam);

        x = pointInWorld[0][3];
        y = pointInWorld[1][3];
        z = pointInWorld[2][3];

        depthOut[pixelID] = float3(x,y,z);
    } 
    else
    {
        depthOut[pixelID] = float3(0,0,0);
        colorOut[pixelID] = float4(1,1,1,0);
    }
}

